<script type="text/javascript">
        var gk_isXlsx = false;
        var gk_xlsxFileLookup = {};
        var gk_fileData = {};
        function filledCell(cell) {
          return cell !== '' && cell != null;
        }
        function loadFileData(filename) {
        if (gk_isXlsx && gk_xlsxFileLookup[filename]) {
            try {
                var workbook = XLSX.read(gk_fileData[filename], { type: 'base64' });
                var firstSheetName = workbook.SheetNames[0];
                var worksheet = workbook.Sheets[firstSheetName];

                // Convert sheet to JSON to filter blank rows
                var jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1, blankrows: false, defval: '' });
                // Filter out blank rows (rows where all cells are empty, null, or undefined)
                var filteredData = jsonData.filter(row => row.some(filledCell));

                // Heuristic to find the header row by ignoring rows with fewer filled cells than the next row
                var headerRowIndex = filteredData.findIndex((row, index) =>
                  row.filter(filledCell).length >= filteredData[index + 1]?.filter(filledCell).length
                );
                // Fallback
                if (headerRowIndex === -1 || headerRowIndex > 25) {
                  headerRowIndex = 0;
                }

                // Convert filtered JSON back to CSV
                var csv = XLSX.utils.aoa_to_sheet(filteredData.slice(headerRowIndex)); // Create a new sheet from filtered array of arrays
                csv = XLSX.utils.sheet_to_csv(csv, { header: 1 });
                return csv;
            } catch (e) {
                console.error(e);
                return "";
            }
        }
        return gk_fileData[filename] || "";
        }
        </script><!DOCTYPE html>
<html>
<head>
  <title>Carte antennes 3G/4G/5G sans clusters</title>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

  <style>
    html, body, #map {
      height: 100%;
      margin: 0;
      padding: 0;
    }
    #controls {
      position: absolute;
      top: 10px;
      right: 10px;
      background: white;
      padding: 10px;
      z-index: 1000;
      border-radius: 4px;
      box-shadow: 0 0 4px rgba(0, 0, 0, 0.2);
      font-family: Arial, sans-serif;
      font-size: 12px;
      user-select: none;
      display: flex;
      flex-direction: column;
      gap: 10px;
    }
    #operator-group, #freq-group, #network-group {
      display: flex;
      justify-content: space-between;
      gap: 10px;
    }
    label {
      cursor: pointer;
      display: block;
    }
  </style>
</head>
<body>

  <div id="controls">
    <div id="operator-group">
      <label><input type="radio" name="operatorFilter" value="Sunrise" checked> Sunrise</label>
      <label><input type="radio" name="operatorFilter" value="Salt"> Salt</label>
      <label><input type="radio" name="operatorFilter" value="Swisscom"> Swisscom</label>
    </div>
    <div id="network-group">
      <label><input type="radio" name="networkFilter" value="3G"> 3G</label>
      <label><input type="radio" name="networkFilter" value="4G"> 4G</label>
      <label><input type="radio" name="networkFilter" value="5G" checked> 5G</label>
    </div>
    <div id="freq-group">
      <label><input type="radio" name="freqFilter" value="freq1" checked> 750 MHz</label>
      <label><input type="radio" name="freqFilter" value="freq2"> 950 MHz</label>
      <label><input type="radio" name="freqFilter" value="freq3"> 2100 MHz</label>
      <label><input type="radio" name="freqFilter" value="freq4"> 3500 MHz</label>
    </div>
  </div>

  <div id="map"></div>

  <script>
    // Initialisation de la carte
    var map = L.map('map', {
      zoomControl: false // Désactive le contrôle de zoom par défaut
    }).setView([46.8, 8.2], 8);

    // Ajout du contrôle de zoom dans le coin inférieur gauche
    L.control.zoom({
      position: 'bottomleft'
    }).addTo(map);

    // Ajout des tuiles de la carte
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      attribution: '© OpenStreetMap contributors'
    }).addTo(map);

    var geojsonURLs = {
      Sunrise_3G: 'https://raw.githubusercontent.com/AntenneCarte/1/main/Sunrise_3G.geojson',
      Sunrise_4G: 'https://raw.githubusercontent.com/AntenneCarte/1/main/Sunrise_4G.geojson',
      Sunrise_5G: 'https://raw.githubusercontent.com/AntenneCarte/1/main/Sunrise_5G.geojson',
      Salt_3G: 'https://raw.githubusercontent.com/AntenneCarte/1/main/Salt_3G.geojson',
      Salt_4G: 'https://raw.githubusercontent.com/AntenneCarte/1/main/Salt_4G.geojson',
      Salt_5G: 'https://raw.githubusercontent.com/AntenneCarte/1/main/Salt_5G.geojson',
      Swisscom_3G: 'https://raw.githubusercontent.com/AntenneCarte/1/main/Swisscom_3G.geojson',
      Swisscom_4G: 'https://raw.githubusercontent.com/AntenneCarte/1/main/Swisscom_4G.geojson',
      Swisscom_5G: 'https://raw.githubusercontent.com/AntenneCarte/1/main/Swisscom_5G.geojson'
    };

    var cachedData = {};
    var layers = {
      freq1: { markers: L.layerGroup(), sectors: L.layerGroup() },
      freq2: { markers: L.layerGroup(), sectors: L.layerGroup() },
      freq3: { markers: L.layerGroup(), sectors: L.layerGroup() },
      freq4: { markers: L.layerGroup(), sectors: L.layerGroup() }
    };

    var currentOperator = "Sunrise";
    var currentNetwork = "5G";
    var currentFrequency = "freq1";
    var sectorRadius = 500 / 3;
    const MIN_ZOOM_FOR_SECTORS = 10;
    const MAX_DISTANCE_FOR_SECTORS = 5000;

    function createAzimuthSector(lat, lon, azimuth, angleWidth, radius) {
      var points = [];
      var numPoints = 30;
      points.push([lat, lon]);

      var azimuthRad = azimuth * Math.PI / 180;
      var angleStart = azimuthRad - (angleWidth * Math.PI / 180) / 2;
      var angleEnd = azimuthRad + (angleWidth * Math.PI / 180) / 2;

      for (var i = 0; i <= numPoints; i++) {
        var angle = angleStart + (angleEnd - angleStart) * (i / numPoints);
        var dx = radius * Math.sin(angle);
        var dy = radius * Math.cos(angle);

        var newLat = lat + (dy / 111320);
        var newLon = lon + (dx / (111320 * Math.cos(lat * Math.PI / 180)));

        points.push([newLat, newLon]);
      }
      return points;
    }

    function updateMap() {
      for (const key in layers) {
        map.removeLayer(layers[key].markers);
        map.removeLayer(layers[key].sectors);
        layers[key].markers.clearLayers();
        layers[key].sectors.clearLayers();
      }

      var cacheKey = `${currentOperator}_${currentNetwork}`;
      var url = geojsonURLs[cacheKey];

      if (cachedData[cacheKey]) {
        processGeojson(cachedData[cacheKey]);
      } else {
        fetch(url)
          .then(response => response.json())
          .then(data => {
            cachedData[cacheKey] = data;
            processGeojson(data);
          })
          .catch(err => console.error("Erreur chargement GeoJSON:", err));
      }
    }

    function processGeojson(data) {
      var markerCoords = {};
      var mapCenter = map.getCenter();

      data.features.forEach(feature => {
        if (feature.geometry.type === "Point") {
          var coords = feature.geometry.coordinates;
          var lon = coords[0];
          var lat = coords[1];
          var props = feature.properties;

          var azimutStr = props["Azimut"] || "0°";
          var azimut = parseFloat(azimutStr.replace("°", ""));
          var freqStr = props["frequency (MHz)"] || "0 MHz";
          var freq = parseFloat(freqStr.replace(/[^\d.]/g, '')) || 0;
          var powerStr = props["Power (W)"] || "N/A";

          var targetLayer;
          if (freq < 900) {
            targetLayer = "freq1";
          } else if (freq >= 900 && freq <= 1000) {
            targetLayer = "freq2";
          } else if (freq > 1000 && freq <= 3000) {
            targetLayer = "freq3";
          } else if (freq > 3000) {
            targetLayer = "freq4";
          }

          if (targetLayer === currentFrequency) {
            var coordKey = `${lat.toFixed(6)},${lon.toFixed(6)}`;
            if (!markerCoords[coordKey]) {
              var marker = L.circleMarker([lat, lon], {
                radius: 5,
                color: 'red',
                fillColor: 'red',
                fillOpacity: 0.8
              });
              markerCoords[coordKey] = marker;
              layers[currentFrequency].markers.addLayer(marker);
            }

            if (map.getZoom() >= MIN_ZOOM_FOR_SECTORS) {
              var antennaPos = L.latLng(lat, lon);
              var distance = mapCenter.distanceTo(antennaPos);

              if (distance <= MAX_DISTANCE_FOR_SECTORS) {
                var sectorPoints = createAzimuthSector(lat, lon, azimut, 60, sectorRadius);
                var sector = L.polygon(sectorPoints, {
                  color: 'blue',
                  fillColor: 'blue',
                  fillOpacity: 0.3,
                  weight: 1
                });

                var popupContent =
                  `<b>Fréquence :</b> ${freq} MHz<br>` +
                  `<b>Puissance :</b> ${powerStr}<br>` +
                  `<b>Azimut :</b> ${azimut}°`;
                sector.bindPopup(popupContent);

                layers[currentFrequency].sectors.addLayer(sector);
              }
            }
          }
        }
      });

      map.addLayer(layers[currentFrequency].markers);
      map.addLayer(layers[currentFrequency].sectors);
    }

    document.querySelectorAll('input[name="operatorFilter"]').forEach(radio => {
      radio.addEventListener('change', function() {
        if (this.checked) {
          currentOperator = this.value;
          updateMap();
        }
      });
    });

    document.querySelectorAll('input[name="networkFilter"]').forEach(radio => {
      radio.addEventListener('change', function() {
        if (this.checked) {
          currentNetwork = this.value;
          updateMap();
        }
      });
    });

    document.querySelectorAll('input[name="freqFilter"]').forEach(radio => {
      radio.addEventListener('change', function() {
        if (this.checked) {
          currentFrequency = this.value;
          updateMap();
        }
      });
    });

    let debounceTimeout;
    function debounceUpdateMap() {
      clearTimeout(debounceTimeout);
      debounceTimeout = setTimeout(updateMap, 300);
    }

    map.on('zoomend moveend', debounceUpdateMap);

    updateMap();
  </script>
</body>
</html>