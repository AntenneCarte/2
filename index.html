<!DOCTYPE html>
<html>
<head>
  <title>Carte antennes sans clusters</title>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>

  <style>
    html, body, #map {
      height: 100%;
      margin: 0;
      padding: 0;
    }
    #controls {
      position: absolute;
      top: 5px;
      right: 5px;
      background: white;
      padding: 5px;
      z-index: 1000;
      border-radius: 4px;
      box-shadow: 0 0 4px rgba(0, 0, 0, 0.2);
      font-family: Arial, sans-serif;
      font-size: 10px;
      user-select: none;
      display: flex;
      flex-direction: column;
      gap: 4px;
      width: auto;
      min-width: 160px;
    }
    #operator-group, #tech-group, #freq-group {
      display: flex;
      flex-direction: row;
      align-items: center;
      gap: 6px;
      flex-wrap: wrap;
    }
    .group-label {
      font-weight: bold;
      white-space: nowrap;
    }
    .button-group, .button-group-second {
      display: flex;
      flex-wrap: wrap;
      gap: 3px;
    }
    .filter-button {
      background: #f0f0f0;
      border: 1px solid #ccc;
      border-radius: 3px;
      padding: 3px 6px;
      cursor: pointer;
      font-size: 10px;
      transition: background 0.2s;
    }
    .filter-button.active {
      background: #007bff;
      color: white;
      border-color: #007bff;
    }
    .filter-button:hover {
      background: #e0e0e0;
    }
    .filter-button.active:hover {
      background: #0056b3;
    }
    .filter-button.no-antennas {
      background: #ff6666;
      color: white;
      border-color: #ff6666;
    }
    .filter-button.no-antennas:hover {
      background: #cc3333;
    }
    .filter-button.no-antennas.active {
      background: #990000;
      color: white;
      border-color: #990000;
    }
    .filter-button.no-antennas.active:hover {
      background: #660000;
    }
    #last-update {
      font-size: 9px;
      color: gray;
      white-space: nowrap;
      border: 1px solid #ccc;
      padding: 2px 4px;
      border-radius: 3px;
      margin-left: auto;
    }
    #operator-group {
      display: flex;
      align-items: center;
      gap: 6px;
      flex-wrap: nowrap;
    }
    @media (max-width: 600px) {
      #controls {
        top: 3px;
        right: 3px;
        padding: 4px;
        min-width: 140px;
      }
      .filter-button {
        padding: 2px 5px;
        font-size: 9px;
      }
      #operator-group {
        flex-wrap: wrap;
      }
      #last-update {
        margin-left: 0;
        margin-top: 3px;
      }
      #freq-group {
        flex-direction: column;
        align-items: flex-start;
      }
      .button-group, .button-group-second {
        flex-wrap: nowrap;
      }
      .button-group-second {
        margin-top: 3px;
      }
    }
  </style>
</head>
<body>

  <div id="map"></div>
  <div id="controls">
    <div id="operator-group">
      <span class="group-label">Operator:</span>
      <div class="button-group">
        <button class="filter-button active" data-type="operator" data-value="Sunrise">Sunrise</button>
        <button class="filter-button" data-type="operator" data-value="Salt">Salt</button>
        <button class="filter-button" data-type="operator" data-value="Swisscom">Swisscom</button>
      </div>
      <div id="last-update">Last update May 2025</div>
    </div>
    <div id="tech-group">
      <span class="group-label">Technology:</span>
      <div class="button-group">
        <button class="filter-button" data-type="tech" data-value="3G">3G</button>
        <button class="filter-button" data-type="tech" data-value="4G">4G</button>
        <button class="filter-button active" data-type="tech" data-value="5G">5G</button>
      </div>
    </div>
    <div id="freq-group">
      <span class="group-label">Frequency:</span>
      <div class="button-group">
        <button class="filter-button active" data-type="freq" data-value="freq1">700 MHz</button>
        <button class="filter-button" data-type="freq" data-value="freq2">800 MHz</button>
        <button class="filter-button" data-type="freq" data-value="freq3">900 MHz</button>
        <button class="filter-button" data-type="freq" data-value="freq4">1400 MHz</button>
      </div>
      <div class="button-group-second">
        <button class="filter-button" data-type="freq" data-value="freq5">1800 MHz</button>
        <button class="filter-button" data-type="freq" data-value="freq6">2100 MHz</button>
        <button class="filter-button" data-type="freq" data-value="freq7">2600 MHz</button>
        <button class="filter-button" data-type="freq" data-value="freq8">3500 MHz</button>
      </div>
    </div>
  </div>

  <script>
    var gk_isXlsx = false;
    var gk_xlsxFileLookup = {};
    var gk_fileData = {};
    function filledCell(cell) {
      return cell !== '' && cell != null;
    }
    function loadFileData(filename) {
      if (gk_isXlsx && gk_xlsxFileLookup[filename]) {
        try {
          var workbook = XLSX.read(gk_fileData[filename], { type: 'base64' });
          var firstSheetName = workbook.SheetNames[0];
          var worksheet = workbook.Sheets[firstSheetName];

          var jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1, blankrows: false, defval: '' });
          var filteredData = jsonData.filter(row => row.some(filledCell));

          var headerRowIndex = filteredData.findIndex((row, index) =>
            row.filter(filledCell).length >= filteredData[index + 1]?.filter(filledCell).length
          );
          if (headerRowIndex === -1 || headerRowIndex > 25) {
            headerRowIndex = 0;
          }

          var csv = XLSX.utils.aoa_to_sheet(filteredData.slice(headerRowIndex));
          csv = XLSX.utils.sheet_to_csv(csv, { header: 1 });
          return csv;
        } catch (e) {
          console.error("Error in loadFileData for file:", filename, e);
          return "";
        }
      }
      return gk_fileData[filename] || "";
    }

    var map = L.map('map', {
      zoomControl: false
    }).setView([46.8, 8.2], 8);

    L.control.zoom({ position: 'bottomleft' }).addTo(map);

    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      attribution: 'Â© OpenStreetMap contributors'
    }).addTo(map);

    const geojsonURLs = {
      Sunrise: {
        "3G": 'https://raw.githubusercontent.com/AntenneCarte/1/main/Sunrise_3G.geojson',
        "4G": 'https://raw.githubusercontent.com/AntenneCarte/1/main/Sunrise_4G.geojson',
        "5G": 'https://raw.githubusercontent.com/AntenneCarte/1/main/Sunrise_5G.geojson'
      },
      Salt: {
        "3G": 'https://raw.githubusercontent.com/AntenneCarte/1/main/Salt_3G.geojson',
        "4G": 'https://raw.githubusercontent.com/AntenneCarte/1/main/Salt_4G.geojson',
        "5G": 'https://raw.githubusercontent.com/AntenneCarte/1/main/Salt_5G.geojson'
      },
      Swisscom: {
        "3G": 'https://raw.githubusercontent.com/AntenneCarte/1/main/Swisscom_3G.geojson',
        "4G": 'https://raw.githubusercontent.com/AntenneCarte/1/main/Swisscom_4G.geojson',
        "5G": 'https://raw.githubusercontent.com/AntenneCarte/1/main/Swisscom_5G.geojson'
      }
    };

    let currentOperator = "Sunrise";
    let currentTechnology = "5G";
    let currentFrequency = "freq1";
    const sectorRadius = 500 / 3;
    const MIN_ZOOM_FOR_SECTORS = 10;
    const MAX_DISTANCE_FOR_SECTORS = 5000;

    const layers = {
      freq1: { markers: L.layerGroup(), sectors: L.layerGroup() },
      freq2: { markers: L.layerGroup(), sectors: L.layerGroup() },
      freq3: { markers: L.layerGroup(), sectors: L.layerGroup() },
      freq4: { markers: L.layerGroup(), sectors: L.layerGroup() },
      freq5: { markers: L.layerGroup(), sectors: L.layerGroup() },
      freq6: { markers: L.layerGroup(), sectors: L.layerGroup() },
      freq7: { markers: L.layerGroup(), sectors: L.layerGroup() },
      freq8: { markers: L.layerGroup(), sectors: L.layerGroup() }
    };

    function createAzimuthSector(lat, lon, azimuth, angleWidth, radius) {
      const points = [[lat, lon]];
      const azimuthRad = azimuth * Math.PI / 180;
      const angleStart = azimuthRad - angleWidth * Math.PI / 180 / 2;
      const angleEnd = azimuthRad + angleWidth * Math.PI / 180 / 2;

      for (let i = 0; i <= 30; i++) {
        const angle = angleStart + (angleEnd - angleStart) * (i / 30);
        const dx = radius * Math.sin(angle);
        const dy = radius * Math.cos(angle);
        const newLat = lat + dy / 111320;
        const newLon = lon + dx / (111320 * Math.cos(lat * Math.PI / 180));
        points.push([newLat, newLon]);
      }
      return points;
    }

    function checkFrequenciesAvailability(operator, technology) {
      const url = geojsonURLs[operator][technology];
      fetch(url)
        .then(response => {
          if (!response.ok) {
            throw new Error(`HTTP error! Status: ${response.status} for URL: ${url}`);
          }
          return response.json();
        })
        .then(data => {
          const frequencyCounts = {
            freq1: 0, // 700 MHz
            freq2: 0, // 800 MHz
            freq3: 0, // 900 MHz
            freq4: 0, // 1400 MHz
            freq5: 0, // 1800 MHz
            freq6: 0, // 2100 MHz
            freq7: 0, // 2600 MHz
            freq8: 0  // 3500 MHz
          };

          data.features.forEach(feature => {
            if (feature.geometry.type !== "Point") return;
            const props = feature.properties;
            const freqStr = props["frequency (MHz)"] || "0 MHz";
            const freq = parseFloat(freqStr.replace(/[^\d.]/g, '')) || 0;

            if (freq < 800) frequencyCounts.freq1++;
            else if (freq < 900) frequencyCounts.freq2++;
            else if (freq < 1000) frequencyCounts.freq3++;
            else if (freq < 1500) frequencyCounts.freq4++;
            else if (freq < 1900) frequencyCounts.freq5++;
            else if (freq < 2300) frequencyCounts.freq6++;
            else if (freq < 2700) frequencyCounts.freq7++;
            else frequencyCounts.freq8++;
          });

          document.querySelectorAll('.filter-button[data-type="freq"]').forEach(btn => {
            const freqValue = btn.dataset.value;
            btn.classList.toggle('no-antennas', frequencyCounts[freqValue] === 0);
          });
        })
        .catch(err => {
          console.error("Error in checkFrequenciesAvailability for", operator, technology, "URL:", url, err);
        });
    }

    function updateMap() {
      for (const key in layers) {
        map.removeLayer(layers[key].markers);
        map.removeLayer(layers[key].sectors);
        layers[key].markers.clearLayers();
        layers[key].sectors.clearLayers();
      }

      const url = geojsonURLs[currentOperator][currentTechnology];
      const mapCenter = map.getCenter();
      const markerCoords = {};

      fetch(url)
        .then(response => {
          if (!response.ok) {
            throw new Error(`HTTP error! Status: ${response.status} for URL: ${url}`);
          }
          return response.json();
        })
        .then(data => {
          data.features.forEach(feature => {
            if (feature.geometry.type !== "Point") return;

            const [lon, lat] = feature.geometry.coordinates;
            const props = feature.properties;
            const freqStr = props["frequency (MHz)"] || "0 MHz";
            const freq = parseFloat(freqStr.replace(/[^\d.]/g, '')) || 0;
            const azimut = parseFloat((props["Azimut"] || "0Â°").replace("Â°", "")) || 0;

            let targetLayer = null;
            if (freq < 800) targetLayer = "freq1"; // 700 MHz
            else if (freq < 900) targetLayer = "freq2"; // 800 MHz
            else if (freq < 1000) targetLayer = "freq3"; // 900 MHz
            else if (freq < 1500) targetLayer = "freq4"; // 1400 MHz
            else if (freq < 1900) targetLayer = "freq5"; // 1800 MHz
            else if (freq < 2300) targetLayer = "freq6"; // 2100 MHz
            else if (freq < 2700) targetLayer = "freq7"; // 2600 MHz
            else targetLayer = "freq8"; // 3500 MHz

            if (targetLayer === currentFrequency) {
              const key = `${lat.toFixed(6)},${lon.toFixed(6)}`;
              if (!markerCoords[key]) {
                const marker = L.circleMarker([lat, lon], {
                  radius: 5,
                  color: 'red',
                  fillColor: 'red',
                  fillOpacity: 0.8
                });
                markerCoords[key] = marker;
                layers[currentFrequency].markers.addLayer(marker);
              }

              if (map.getZoom() >= MIN_ZOOM_FOR_SECTORS) {
                const distance = mapCenter.distanceTo([lat, lon]);
                if (distance <= MAX_DISTANCE_FOR_SECTORS) {
                  const sector = L.polygon(createAzimuthSector(lat, lon, azimut, 60, sectorRadius), {
                    color: 'blue',
                    fillColor: 'blue',
                    fillOpacity: 0.3,
                    weight: 1
                  });

                  const adaptive = props["Adaptive mode"];
                  const adaptiveText = adaptive == "1" ? "Yes" : "No";

                  const pci = props["PCI"] || "not available for this antenna";
                  const commissioning = props["Commissioning date"] || "Unknown";

                  const popup = `
                    <b>Frequency:</b> ${freqStr}<br>
                    <b>Power:</b> Coming soon<br>
                    <b>Adaptive mode:</b> ${adaptiveText}<br>
                    <b>PCI:</b> ${pci}<br>
                    <b>Commissioning date:</b> ${commissioning}
                  `;
                  sector.bindPopup(popup);
                  layers[currentFrequency].sectors.addLayer(sector);
                }
              }
            }
          });

          map.addLayer(layers[currentFrequency].markers);
          map.addLayer(layers[currentFrequency].sectors);
        })
        .catch(err => {
          console.error("Error in updateMap for", currentOperator, currentTechnology, "URL:", url, err);
        });
    }

    function updateButtonStyles(type, value) {
      document.querySelectorAll(`.filter-button[data-type="${type}"]`).forEach(btn => {
        btn.classList.toggle('active', btn.dataset.value === value);
      });
    }

    document.querySelectorAll('.filter-button[data-type="operator"]').forEach(btn => {
      btn.addEventListener('click', function () {
        currentOperator = this.dataset.value;
        updateButtonStyles('operator', currentOperator);
        checkFrequenciesAvailability(currentOperator, currentTechnology);
        updateMap();
      });
    });

    document.querySelectorAll('.filter-button[data-type="tech"]').forEach(btn => {
      btn.addEventListener('click', function () {
        currentTechnology = this.dataset.value;
        updateButtonStyles('tech', currentTechnology);
        checkFrequenciesAvailability(currentOperator, currentTechnology);
        updateMap();
      });
    });

    document.querySelectorAll('.filter-button[data-type="freq"]').forEach(btn => {
      btn.addEventListener('click', function () {
        currentFrequency = this.dataset.value;
        updateButtonStyles('freq', currentFrequency);
        updateMap();
      });
    });

    map.on('zoomend moveend', updateMap);
    checkFrequenciesAvailability(currentOperator, currentTechnology);
    updateMap();
  </script>
</body>
</html>
